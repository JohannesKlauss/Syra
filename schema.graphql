# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AggregateProject {
  avg: ProjectAvgAggregateOutputType
  count: Int!
  max: ProjectMaxAggregateOutputType
  min: ProjectMinAggregateOutputType
  sum: ProjectSumAggregateOutputType
}

type AggregateUser {
  avg: UserAvgAggregateOutputType
  count: Int!
  max: UserMaxAggregateOutputType
  min: UserMinAggregateOutputType
  sum: UserSumAggregateOutputType
}

type BatchPayload {
  count: Int!
}

input DateTimeFieldUpdateOperationsInput {
  set: Timestamp
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input IntFieldUpdateOperationsInput {
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

type Mutation {
  createLocalUser(data: SignUpUserLocalInput!): User
  createProject(data: ProjectCreateInput!): Project!
  createUser(data: UserCreateInput!): User!
  deleteManyProject(where: ProjectWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteUser(where: UserWhereUniqueInput!): User
  updateManyProject(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertProject(create: ProjectCreateInput!, update: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableIntFieldUpdateOperationsInput {
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Project {
  createdAt: Timestamp!
  id: Int!
  name: String!
  ownerId: Int!
  updatedAt: Timestamp!
  User: User!
}

type ProjectAvgAggregateOutputType {
  id: Float!
  ownerId: Float!
}

input ProjectCreateInput {
  createdAt: Timestamp
  name: String!
  updatedAt: Timestamp
  User: UserCreateOneWithoutProjectInput!
}

input ProjectCreateManyWithoutUserInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutUserInput!]
}

input ProjectCreateWithoutUserInput {
  createdAt: Timestamp
  name: String!
  updatedAt: Timestamp
}

enum ProjectDistinctFieldEnum {
  createdAt
  id
  name
  ownerId
  updatedAt
}

input ProjectListRelationFilter {
  every: ProjectWhereInput
  none: ProjectWhereInput
  some: ProjectWhereInput
}

type ProjectMaxAggregateOutputType {
  id: Int!
  ownerId: Int!
}

type ProjectMinAggregateOutputType {
  id: Int!
  ownerId: Int!
}

input ProjectOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  ownerId: SortOrder
  updatedAt: SortOrder
}

input ProjectScalarWhereInput {
  AND: [ProjectScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  ownerId: IntFilter
  updatedAt: DateTimeFilter
}

type ProjectSumAggregateOutputType {
  id: Int!
  ownerId: Int!
}

input ProjectUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  User: UserUpdateOneRequiredWithoutProjectInput
}

input ProjectUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyWithoutUserInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutUserInput!]
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutUserInput!]
}

input ProjectUpdateManyWithWhereNestedInput {
  data: ProjectUpdateManyDataInput!
  where: ProjectScalarWhereInput!
}

input ProjectUpdateWithoutUserDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithWhereUniqueWithoutUserInput {
  data: ProjectUpdateWithoutUserDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithWhereUniqueWithoutUserInput {
  create: ProjectCreateWithoutUserInput!
  update: ProjectUpdateWithoutUserDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  ownerId: IntFilter
  updatedAt: DateTimeFilter
  User: UserRelationFilter
}

input ProjectWhereUniqueInput {
  id: Int
}

type Query {
  aggregateProject(cursor: ProjectWhereUniqueInput, distinct: [ProjectDistinctFieldEnum!], orderBy: [ProjectOrderByInput!], skip: Int, take: Int, where: ProjectWhereInput): AggregateProject!
  aggregateUser(cursor: UserWhereUniqueInput, distinct: [UserDistinctFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstProject(cursor: ProjectWhereUniqueInput, distinct: [ProjectDistinctFieldEnum!], orderBy: [ProjectOrderByInput!], skip: Int, take: Int, where: ProjectWhereInput): Project
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserDistinctFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): User
  project(where: ProjectWhereUniqueInput!): Project
  projects(cursor: ProjectWhereUniqueInput, distinct: [ProjectDistinctFieldEnum!], orderBy: [ProjectOrderByInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserDistinctFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

"""New recipe data"""
input SignUpUserLocalInput {
  email: String!
  name: String!
  password: String!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type User {
  avatar: String
  createdAt: Timestamp!
  email: String!
  id: Int!
  lastOnline: Timestamp!
  name: String!
  Project(cursor: ProjectWhereUniqueInput, distinct: [ProjectDistinctFieldEnum!], orderBy: [ProjectOrderByInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]
  tier: Int!
}

type UserAvgAggregateOutputType {
  id: Float!
  socialLoginType: Float
  tier: Float!
}

input UserCreateInput {
  avatar: String
  createdAt: Timestamp
  email: String!
  lastOnline: Timestamp
  name: String!
  password: String
  Project: ProjectCreateManyWithoutUserInput
  socialLoginToken: String
  socialLoginType: Int
  tier: Int
}

input UserCreateOneWithoutProjectInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutProjectInput
}

input UserCreateWithoutProjectInput {
  avatar: String
  createdAt: Timestamp
  email: String!
  lastOnline: Timestamp
  name: String!
  password: String
  socialLoginToken: String
  socialLoginType: Int
  tier: Int
}

enum UserDistinctFieldEnum {
  avatar
  createdAt
  email
  id
  lastOnline
  name
  password
  socialLoginToken
  socialLoginType
  tier
}

type UserMaxAggregateOutputType {
  id: Int!
  socialLoginType: Int
  tier: Int!
}

type UserMinAggregateOutputType {
  id: Int!
  socialLoginType: Int
  tier: Int!
}

input UserOrderByInput {
  avatar: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  lastOnline: SortOrder
  name: SortOrder
  password: SortOrder
  socialLoginToken: SortOrder
  socialLoginType: SortOrder
  tier: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

type UserSumAggregateOutputType {
  id: Int!
  socialLoginType: Int
  tier: Int!
}

input UserUpdateInput {
  avatar: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  lastOnline: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  Project: ProjectUpdateManyWithoutUserInput
  socialLoginToken: NullableStringFieldUpdateOperationsInput
  socialLoginType: NullableIntFieldUpdateOperationsInput
  tier: IntFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  avatar: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  lastOnline: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  socialLoginToken: NullableStringFieldUpdateOperationsInput
  socialLoginType: NullableIntFieldUpdateOperationsInput
  tier: IntFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutProjectInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutProjectInput
  update: UserUpdateWithoutProjectDataInput
  upsert: UserUpsertWithoutProjectInput
}

input UserUpdateWithoutProjectDataInput {
  avatar: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  lastOnline: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  socialLoginToken: NullableStringFieldUpdateOperationsInput
  socialLoginType: NullableIntFieldUpdateOperationsInput
  tier: IntFieldUpdateOperationsInput
}

input UserUpsertWithoutProjectInput {
  create: UserCreateWithoutProjectInput!
  update: UserUpdateWithoutProjectDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  avatar: StringNullableFilter
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  lastOnline: DateTimeFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringNullableFilter
  Project: ProjectListRelationFilter
  socialLoginToken: StringNullableFilter
  socialLoginType: IntNullableFilter
  tier: IntFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
  name: String
}
