# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Address {
  addressLine1: String!
  addressLine2: String
  city: String!
  country: String!
  createdAt: Timestamp!
  id: String!
  state: String!
  updatedAt: Timestamp!
  User(cursor: UserWhereUniqueInput, distinct: [UserDistinctFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]
  zip: Int!
}

type AddressAvgAggregate {
  zip: Float!
}

input AddressCreateInput {
  addressLine1: String!
  addressLine2: String
  city: String!
  country: String!
  createdAt: Timestamp
  id: String
  state: String!
  updatedAt: Timestamp
  User: UserCreateManyWithoutAddressInput
  zip: Int!
}

input AddressCreateOneWithoutUserInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutUserInput
}

input AddressCreateWithoutUserInput {
  addressLine1: String!
  addressLine2: String
  city: String!
  country: String!
  createdAt: Timestamp
  id: String
  state: String!
  updatedAt: Timestamp
  zip: Int!
}

enum AddressDistinctFieldEnum {
  addressLine1
  addressLine2
  city
  country
  createdAt
  id
  state
  updatedAt
  zip
}

type AddressMaxAggregate {
  zip: Int!
}

type AddressMinAggregate {
  zip: Int!
}

input AddressOrderByInput {
  addressLine1: SortOrder
  addressLine2: SortOrder
  city: SortOrder
  country: SortOrder
  createdAt: SortOrder
  id: SortOrder
  state: SortOrder
  updatedAt: SortOrder
  zip: SortOrder
}

input AddressRelationFilter {
  is: AddressWhereInput
  isNot: AddressWhereInput
}

type AddressSumAggregate {
  zip: Int!
}

input AddressUpdateInput {
  addressLine1: StringFieldUpdateOperationsInput
  addressLine2: NullableStringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  state: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  User: UserUpdateManyWithoutAddressInput
  zip: IntFieldUpdateOperationsInput
}

input AddressUpdateManyMutationInput {
  addressLine1: StringFieldUpdateOperationsInput
  addressLine2: NullableStringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  state: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  zip: IntFieldUpdateOperationsInput
}

input AddressUpdateOneWithoutUserInput {
  connect: AddressWhereUniqueInput
  create: AddressCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: AddressUpdateWithoutUserDataInput
  upsert: AddressUpsertWithoutUserInput
}

input AddressUpdateWithoutUserDataInput {
  addressLine1: StringFieldUpdateOperationsInput
  addressLine2: NullableStringFieldUpdateOperationsInput
  city: StringFieldUpdateOperationsInput
  country: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  state: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  zip: IntFieldUpdateOperationsInput
}

input AddressUpsertWithoutUserInput {
  create: AddressCreateWithoutUserInput!
  update: AddressUpdateWithoutUserDataInput!
}

input AddressWhereInput {
  addressLine1: StringFilter
  addressLine2: StringNullableFilter
  AND: [AddressWhereInput!]
  city: StringFilter
  country: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  state: StringFilter
  updatedAt: DateTimeFilter
  User: UserListRelationFilter
  zip: IntFilter
}

input AddressWhereUniqueInput {
  id: String
}

type AggregateAddress {
  avg: AddressAvgAggregate
  count: Int!
  max: AddressMaxAggregate
  min: AddressMinAggregate
  sum: AddressSumAggregate
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Int!
}

input DateTimeFieldUpdateOperationsInput {
  set: Timestamp
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input IntFieldUpdateOperationsInput {
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  createUser(data: UserCreateInput!): User!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddress(where: AddressWhereInput): BatchPayload!
  deleteManyUser(where: UserWhereInput): BatchPayload!
  deleteUser(where: UserWhereUniqueInput!): User
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddress(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertAddress(create: AddressCreateInput!, update: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(cursor: AddressWhereUniqueInput, distinct: [AddressDistinctFieldEnum!], orderBy: [AddressOrderByInput!], skip: Int, take: Int, where: AddressWhereInput): [Address!]!
  aggregateAddress(cursor: AddressWhereUniqueInput, distinct: [AddressDistinctFieldEnum!], orderBy: [AddressOrderByInput!], skip: Int, take: Int, where: AddressWhereInput): AggregateAddress!
  aggregateUser(cursor: UserWhereUniqueInput, distinct: [UserDistinctFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  findFirstAddress(cursor: AddressWhereUniqueInput, distinct: [AddressDistinctFieldEnum!], orderBy: [AddressOrderByInput!], skip: Int, take: Int, where: AddressWhereInput): Address
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserDistinctFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): User
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserDistinctFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  MODERATOR
  USER
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type User {
  address: Address
  addressId: String
  createdAt: Timestamp!
  email: String!
  id: String!
  name: String!
  role: Role!
  session: String
  updatedAt: Timestamp!
}

input UserCreateInput {
  address: AddressCreateOneWithoutUserInput
  createdAt: Timestamp
  email: String!
  id: String
  name: String!
  role: Role
  session: String
  updatedAt: Timestamp
}

input UserCreateManyWithoutAddressInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutAddressInput!]
}

input UserCreateWithoutAddressInput {
  createdAt: Timestamp
  email: String!
  id: String
  name: String!
  role: Role
  session: String
  updatedAt: Timestamp
}

enum UserDistinctFieldEnum {
  addressId
  createdAt
  email
  id
  name
  role
  session
  updatedAt
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  addressId: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  role: SortOrder
  session: SortOrder
  updatedAt: SortOrder
}

input UserScalarWhereInput {
  addressId: StringNullableFilter
  AND: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  role: EnumRoleFilter
  session: StringNullableFilter
  updatedAt: DateTimeFilter
}

input UserUpdateInput {
  address: AddressUpdateOneWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  session: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  session: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  session: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyWithoutAddressInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutAddressInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutAddressInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutAddressInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateWithoutAddressDataInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  session: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithWhereUniqueWithoutAddressInput {
  data: UserUpdateWithoutAddressDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutAddressInput {
  create: UserCreateWithoutAddressInput!
  update: UserUpdateWithoutAddressDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  address: AddressRelationFilter
  addressId: StringNullableFilter
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  role: EnumRoleFilter
  session: StringNullableFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
